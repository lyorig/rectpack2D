#pragma once
#include <optional>
#include <vector>
#include <array>
#include <variant>
#include <memory>
#include <algorithm>

#include "insert_and_split.h"
#include "empty_spaces.h"
#include "empty_space_allocators.h"

#include "best_bin_finder.h"

namespace rectpack2D {
	template <class empty_spaces_type>
	using output_rect_t = typename empty_spaces_type::output_rect_type;

	template <class F, class G>
	struct finder_input {
		const int max_bin_side;
		const int discard_step;
		F handle_successful_insertion;
		G handle_unsuccessful_insertion;
		const flipping_option flipping_mode;
	};

	template <class F, class G>
	auto make_finder_input(
		const int max_bin_side,
		const int discard_step,
		F&& handle_successful_insertion,
		G&& handle_unsuccessful_insertion,
		const flipping_option flipping_mode
	) {
		return finder_input<F, G> { 
			max_bin_side, 
			discard_step, 
			std::forward<F>(handle_successful_insertion),
			std::forward<G>(handle_unsuccessful_insertion),
			flipping_mode
		};
	};

	/*
		Finds the best packing for the rectangles,
		just in the order that they were passed.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G>
	rect_wh find_best_packing_dont_sort(
		Subjects& subjects,
		const finder_input<F, G>& input
	) {
		// Works with C arrays as well.
		using iterator_type = decltype(std::begin(subjects));
		using order_type = rectpack2D::span<iterator_type>;

		return find_best_packing_impl<empty_spaces_type, order_type>(
			[&subjects](auto callback) { callback(order_type(std::begin(subjects), std::end(subjects))); },
			input
		);
	}


	/*
		Finds the best packing for the rectangles.
		Accepts a list of predicates able to compare two input rectangles.
	   
		The function will try to pack the rectangles in all orders generated by the predicates,
		and will only write the x, y coordinates of the best packing found among the orders.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G, class Comparator, class... Comparators>
	rect_wh find_best_packing(
		Subjects& subjects,
		const finder_input<F, G>& input,

		Comparator comparator,
		Comparators... comparators
	) {
		using rect_type = output_rect_t<empty_spaces_type>;
		using order_type = rectpack2D::span<rect_type**>;

		constexpr auto count_orders = 1 + sizeof...(Comparators);
		std::size_t count_valid_subjects = 0;

		// Allocate space assuming no rectangle has an area of zero.
		// We fill orders with valid rectangles only.
		auto orders = std::make_unique<rect_type*[]>(count_orders * std::size(subjects));

		for (auto& s : subjects) {
			auto& r = s.get_rect();

			if (r.area() == 0) {
				continue;
			}

			orders[count_valid_subjects++] = std::addressof(r);
		}

		auto ith_order = [&orders, n = count_valid_subjects](const std::size_t i) {
			return order_type(
				orders.get() + i       * n,
				orders.get() + (i + 1) * n
			);
		};

		{
			/*
				Zero-th order is already filled.
				We duplicate it to all other orders.
			*/
			const auto first_order = ith_order(0);

			for (std::size_t i = 1; i < count_orders; ++i) {
				std::copy(
					first_order.begin(),
					first_order.end(),
					ith_order(i).begin()
				);
			}
		}

		{
			std::size_t i = 0;

			auto make_order = [&i, ith_order](auto& predicate) {
				const auto o = ith_order(i++);
				std::sort(o.begin(), o.end(), predicate);
			};

			make_order(comparator);
			(make_order(comparators), ...);
		}

		return find_best_packing_impl<empty_spaces_type, order_type>(
			[ith_order](auto callback) {
				for (std::size_t i = 0; i < count_orders; ++i) {
					callback(ith_order(i));
				}
			},
			input
		);
	}

	/*
		Finds the best packing for the rectangles.
		Provides a list of several sensible comparison predicates.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G>
	rect_wh find_best_packing(
		Subjects& subjects,
		const finder_input<F, G>& input
	) {
		using rect_type = output_rect_t<empty_spaces_type>;

		return find_best_packing<empty_spaces_type>(
			subjects,
			input,

			[](const rect_type* const a, const rect_type* const b) {
				return a->area() > b->area();
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->perimeter() > b->perimeter();
			},
			[](const rect_type* const a, const rect_type* const b) {
				return std::max(a->w, a->h) > std::max(b->w, b->h);
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->w > b->w;
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->h > b->h;
			}
		);
	}
}
